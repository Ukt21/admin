from __future__ import annotations\nimport aiosqlite\nfrom dataclasses import dataclass\nfrom typing import Optional, List, Tuple, Dict\nfrom dateutil import parser as dtparser\n\nDB_PATH='./bot.db'\n\n@dataclass\nclass User:\n    id:int; tg_id:int; full_name:str; department:Optional[str]\n\nasync def init_db():\n    async with aiosqlite.connect(DB_PATH) as db:\n        await db.execute('CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY AUTOINCREMENT, tg_id INTEGER UNIQUE NOT NULL, full_name TEXT NOT NULL, department TEXT)')\n        await db.execute('CREATE TABLE IF NOT EXISTS shifts (id INTEGER PRIMARY KEY AUTOINCREMENT, user_id INTEGER NOT NULL, work_date TEXT NOT NULL, check_in TEXT, check_out TEXT, UNIQUE(user_id, work_date), FOREIGN KEY(user_id) REFERENCES users(id))')\n        await db.commit()\n\nasync def get_user_by_tg(tg_id:int)->Optional[User]:\n    async with aiosqlite.connect(DB_PATH) as db:\n        db.row_factory=aiosqlite.Row\n        cur=await db.execute('SELECT * FROM users WHERE tg_id=?',(tg_id,))\n        r=await cur.fetchone()\n        if not r: return None\n        return User(id=r['id'], tg_id=r['tg_id'], full_name=r['full_name'], department=r['department'])\n\nasync def create_user(tg_id:int, full_name:str)->User:\n    async with aiosqlite.connect(DB_PATH) as db:\n        await db.execute('INSERT OR IGNORE INTO users(tg_id, full_name) VALUES(?, ?)',(tg_id, full_name))\n        await db.commit()\n    u=await get_user_by_tg(tg_id); assert u is not None; return u\n\nasync def set_user_department(user_id:int, department:str):\n    async with aiosqlite.connect(DB_PATH) as db:\n        await db.execute('UPDATE users SET department=? WHERE id=?',(department,user_id))\n        await db.commit()\n\nasync def get_or_create_shift(user_id:int, work_date:str):\n    async with aiosqlite.connect(DB_PATH) as db:\n        await db.execute('INSERT OR IGNORE INTO shifts(user_id, work_date) VALUES(?, ?)',(user_id, work_date))\n        await db.commit()\n\nasync def set_check_in(user_id:int, work_date:str, ts_iso:str)->Tuple[bool,str]:\n    async with aiosqlite.connect(DB_PATH) as db:\n        db.row_factory=aiosqlite.Row\n        cur=await db.execute('SELECT check_in FROM shifts WHERE user_id=? AND work_date=?',(user_id, work_date))\n        row=await cur.fetchone()\n        if row and row['check_in']: return False,'Уже отмечен приход'\n        await db.execute('UPDATE shifts SET check_in=? WHERE user_id=? AND work_date=?',(ts_iso,user_id,work_date))\n        await db.commit(); return True,'Ок'\n\nasync def set_check_out(user_id:int, work_date:str, ts_iso:str)->Tuple[bool,str]:\n    async with aiosqlite.connect(DB_PATH) as db:\n        db.row_factory=aiosqlite.Row\n        cur=await db.execute('SELECT check_in, check_out FROM shifts WHERE user_id=? AND work_date=?',(user_id, work_date))\n        row=await cur.fetchone()\n        if not row or not row['check_in']: return False,'Сначала отметь приход'\n        if row['check_out']: return False,'Уже отмечен уход'\n        await db.execute('UPDATE shifts SET check_out=? WHERE user_id=? AND work_date=?',(ts_iso,user_id,work_date))\n        await db.commit(); return True,'Ок'\n\nasync def fetch_today_shifts(work_date:str)->List[aiosqlite.Row]:\n    async with aiosqlite.connect(DB_PATH) as db:\n        db.row_factory=aiosqlite.Row\n        cur=await db.execute('SELECT u.full_name, u.department, s.check_in, s.check_out FROM shifts s JOIN users u ON u.id=s.user_id WHERE s.work_date=? ORDER BY u.department, u.full_name',(work_date,))\n        return await cur.fetchall()\n\ndef _minutes_between(ci,co):\n    if not ci or not co: return 0\n    try:\n        t1=dtparser.isoparse(ci); t2=dtparser.isoparse(co)\n        return max(int((t2-t1).total_seconds()//60),0)\n    except: return 0\n\nasync def month_minutes_for_user(user_id:int,y:int,m:int)->int:\n    pref=f"{y:04d}-{m:02d}-"\n    async with aiosqlite.connect(DB_PATH) as db:\n        db.row_factory=aiosqlite.Row\n        cur=await db.execute('SELECT check_in, check_out FROM shifts WHERE user_id=? AND work_date LIKE ?',(user_id,pref+'%'))\n        rows=await cur.fetchall()\n    return sum(_minutes_between(r['check_in'], r['check_out']) for r in rows)\n\nasync def month_days_for_user(user_id:int,y:int,m:int):\n    pref=f"{y:04d}-{m:02d}-"\n    async with aiosqlite.connect(DB_PATH) as db:\n        db.row_factory=aiosqlite.Row\n        cur=await db.execute('SELECT work_date, check_in, check_out FROM shifts WHERE user_id=? AND work_date LIKE ? ORDER BY work_date',(user_id,pref+'%'))\n        rows=await cur.fetchall()\n    out=[]\n    for r in rows:\n        mins=_minutes_between(r['check_in'], r['check_out'])\n        if mins>0: out.append({'date': r['work_date'], 'minutes': mins})\n    return out\n\nasync def month_minutes_by_user(y:int,m:int,start_day=1,end_day=None,department=None):\n    pref=f"{y:04d}-{m:02d}-"\n    async with aiosqlite.connect(DB_PATH) as db:\n        db.row_factory=aiosqlite.Row\n        q='SELECT u.id AS user_id, u.full_name, u.department, s.work_date, s.check_in, s.check_out FROM shifts s JOIN users u ON u.id=s.user_id WHERE s.work_date LIKE ?'\n        params=[pref+'%']\n        if department: q+=' AND u.department = ?'; params.append(department)\n        q+=' ORDER BY u.department, u.full_name, s.work_date'\n        cur=await db.execute(q, params); rows=await cur.fetchall()\n    def in_range(d):\n        day=int(d.split('-')[2])\n        return day>=start_day if end_day is None else (start_day<=day<=end_day)\n    totals={}\n    for r in rows:\n        if not in_range(r['work_date']): continue\n        mins=_minutes_between(r['check_in'], r['check_out'])\n        if mins<=0: continue\n        uid=r['user_id']\n        if uid not in totals: totals[uid]={'user_id':uid,'full_name':r['full_name'],'department':r['department'],'minutes':0}\n        totals[uid]['minutes']+=mins\n    return list(totals.values())\n